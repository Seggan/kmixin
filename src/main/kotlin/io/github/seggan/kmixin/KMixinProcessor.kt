package io.github.seggan.kmixin

import com.google.devtools.ksp.KspExperimental
import com.google.devtools.ksp.processing.CodeGenerator
import com.google.devtools.ksp.processing.Dependencies
import com.google.devtools.ksp.processing.Resolver
import com.google.devtools.ksp.symbol.KSFile
import com.google.devtools.ksp.symbol.KSFunctionDeclaration

@OptIn(KspExperimental::class)
class KMixinProcessor(private val generator: CodeGenerator, private val resolver: Resolver) {
    fun processFile(file: KSFile) {
        val sb = StringBuilder()
        sb.append("// Auto-generated by KMixin\n")
        if (file.packageName.asString().isNotEmpty()) {
            sb.append("package ").append(file.packageName.asString()).append(";\n\n")
        }
        sb.appendLine("import ${SpongeNames.CALLBACK_INFO};")
        sb.appendLine("import ${SpongeNames.CALLBACK_INFO_RETURNABLE};")

        sb.appendLine()
        for (annotation in file.annotations) {
            if (annotation.annotationType.resolve().javaType.startsWith("kotlin.")) continue
            sb.appendLine(annotation.toJava())
        }

        val className = file.fileName.replace(".kt", "Impl")
        sb.append("\npublic class ").append(className).append(" {\n")
        for (function in file.declarations.filter { it.hasAnnotation(SpongeNames.INJECT) }) {
            if (function !is KSFunctionDeclaration) continue
            sb.appendLine(processFunction(function).prependIndent("    "))
        }
        sb.append("}\n")

        generator.createNewFile(
            dependencies = Dependencies(false, file),
            packageName = file.packageName.asString(),
            fileName = className,
            extensionName = "java"
        ).use { it.write(sb.toString().encodeToByteArray()) }
    }

    private fun processFunction(function: KSFunctionDeclaration): String {
        val sb = StringBuilder()
        for (annotation in function.annotations) {
            if (annotation.annotationType.resolve().javaType.startsWith("kotlin.")) continue
            sb.appendLine(annotation.toJava())
        }
        sb.append("private void ").append(function.simpleName.asString()).append('(')
        for (param in function.parameters) {
            val type = param.type.resolve().javaType
            if (type == SpongeNames.CALLBACK_INFO || type == SpongeNames.CALLBACK_INFO_RETURNABLE) continue
            sb.append(param.type.resolve().javaType).append(' ').append(param.name!!.asString()).append(", ")
        }
        val returnType = function.returnType!!.resolve().javaBoxedType
        if (returnType != "void") {
            sb.append("CallbackInfoReturnable<").append(returnType).append("> ci")
        } else {
            sb.append("CallbackInfo ci")
        }
        sb.append(") {\n    ")
        if (returnType != "void") sb.append("ci.setReturnValue(")
        sb.append(resolver.getOwnerJvmClassName(function)!!)
            .append('.')
            .append(resolver.getJvmName(function)!!)
            .append('(')
        if (function.extensionReceiver != null) {
            sb.append('(').append(function.extensionReceiver!!.resolve().javaType).append(") (Object) this")
            if (function.parameters.isNotEmpty()) sb.append(", ")
        }
        for ((i, param) in function.parameters.withIndex()) {
            val type = param.type.resolve().javaType
            if (type == SpongeNames.CALLBACK_INFO || type == SpongeNames.CALLBACK_INFO_RETURNABLE) {
                sb.append("ci")
            } else {
                sb.append(param.name!!.asString())
            }
            if (i < function.parameters.size - 1) sb.append(", ")
        }
        sb.append(")")
        if (returnType != "void") sb.append(")")
        sb.append(";\n}")
        return sb.toString()
    }
}