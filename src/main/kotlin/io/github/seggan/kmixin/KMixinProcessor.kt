package io.github.seggan.kmixin

import com.google.devtools.ksp.KspExperimental
import com.google.devtools.ksp.processing.CodeGenerator
import com.google.devtools.ksp.processing.Dependencies
import com.google.devtools.ksp.processing.Resolver
import com.google.devtools.ksp.symbol.KSAnnotated
import com.google.devtools.ksp.symbol.KSFile
import com.google.devtools.ksp.symbol.KSFunctionDeclaration
import com.google.devtools.ksp.symbol.KSName
import com.google.devtools.ksp.symbol.KSType

@OptIn(KspExperimental::class)
class KMixinProcessor(private val generator: CodeGenerator, private val resolver: Resolver) {
    fun processFile(file: KSFile) {
        val sb = StringBuilder()
        sb.append("// Auto-generated by KMixin\n")
        if (file.packageName.asString().isNotEmpty()) {
            sb.append("package ").append(file.packageName.asString()).append(";\n\n")
        }
        sb.appendLine("import ${SpongeNames.MIXIN};")
        sb.appendLine("import ${SpongeNames.CALLBACK_INFO};")
        sb.appendLine("import ${SpongeNames.CALLBACK_INFO_RETURNABLE};")
        val className = file.fileName.replace(".kt", "Impl")
        sb.append("public class ").append(className).append(" {\n")
        for (function in file.declarations.filter { it.hasAnnotation(SpongeNames.INJECT) }) {
            if (function !is KSFunctionDeclaration) continue
            sb.appendLine(processFunction(function, file.packageName).prependIndent("    "))
        }
        sb.append("}\n")
        generator.createNewFile(
            dependencies = Dependencies(false, file),
            packageName = file.packageName.asString(),
            fileName = className,
            extensionName = "java"
        ).use { it.write(sb.toString().encodeToByteArray()) }
    }

    private fun processFunction(function: KSFunctionDeclaration, pkg: KSName): String {
        val sb = StringBuilder()
        sb.append("public void ").append(function.simpleName.asString()).append('(')
        for (param in function.parameters) {
            val type = param.type.resolve().javaType
            if (type == SpongeNames.CALLBACK_INFO || type == SpongeNames.CALLBACK_INFO_RETURNABLE) continue
            sb.append(param.type.resolve().javaType).append(' ').append(param.name!!.asString()).append(", ")
        }
        val returnType = function.returnType!!.resolve().javaBoxedType
        if (returnType != "void") {
            sb.append("CallbackInfoReturnable<").append(returnType).append("> ci")
        } else {
            sb.append("CallbackInfo ci")
        }
        sb.append(") {\n    ")
        if (returnType != "void") sb.append("ci.setReturnValue(")
        sb.append(resolver.getOwnerJvmClassName(function)!!)
            .append('.')
            .append(resolver.getJvmName(function)!!)
            .append('(')
        if (function.extensionReceiver != null) {
            sb.append('(').append(function.extensionReceiver!!.resolve().javaType).append(") (Object) this")
            if (function.parameters.isNotEmpty()) sb.append(", ")
        }
        for ((i, param) in function.parameters.withIndex()) {
            val type = param.type.resolve().javaType
            if (type == SpongeNames.CALLBACK_INFO || type == SpongeNames.CALLBACK_INFO_RETURNABLE) {
                sb.append("ci")
            } else {
                sb.append(param.name!!.asString())
            }
            if (i < function.parameters.size - 1) sb.append(", ")
        }
        sb.append(")")
        if (returnType != "void") sb.append(")")
        sb.append(";\n}")
        return sb.toString()
    }
}

private val KSType.javaType: String
    get() = when (val asString = declaration.qualifiedName!!.asString()) {
        "kotlin.Int" -> "int"
        "kotlin.Float" -> "float"
        "kotlin.Double" -> "double"
        "kotlin.Long" -> "long"
        "kotlin.Short" -> "short"
        "kotlin.Byte" -> "byte"
        "kotlin.Boolean" -> "boolean"
        "kotlin.Char" -> "char"
        "kotlin.Unit" -> "void"
        "kotlin.String" -> "java.lang.String"
        "kotlin.Any" -> "java.lang.Object"
        "kotlin.Nothing" -> "void"
        "kotlin.IntArray" -> "int[]"
        "kotlin.FloatArray" -> "float[]"
        "kotlin.DoubleArray" -> "double[]"
        "kotlin.LongArray" -> "long[]"
        "kotlin.ShortArray" -> "short[]"
        "kotlin.ByteArray" -> "byte[]"
        "kotlin.BooleanArray" -> "boolean[]"
        "kotlin.CharArray" -> "char[]"
        else -> asString
    }

private val KSType.javaBoxedType: String
    get() = when (val asString = declaration.qualifiedName!!.asString()) {
        "kotlin.Int" -> "java.lang.Integer"
        "kotlin.Float" -> "java.lang.Float"
        "kotlin.Double" -> "java.lang.Double"
        "kotlin.Long" -> "java.lang.Long"
        "kotlin.Short" -> "java.lang.Short"
        "kotlin.Byte" -> "java.lang.Byte"
        "kotlin.Boolean" -> "java.lang.Boolean"
        "kotlin.Char" -> "java.lang.Character"
        "kotlin.Unit" -> "void"
        "kotlin.String" -> "java.lang.String"
        "kotlin.Any" -> "java.lang.Object"
        "kotlin.Nothing" -> "void"
        "kotlin.IntArray" -> "int[]"
        "kotlin.FloatArray" -> "float[]"
        "kotlin.DoubleArray" -> "double[]"
        "kotlin.LongArray" -> "long[]"
        "kotlin.ShortArray" -> "short[]"
        "kotlin.ByteArray" -> "byte[]"
        "kotlin.BooleanArray" -> "boolean[]"
        "kotlin.CharArray" -> "char[]"
        else -> asString
    }

private fun KSAnnotated.hasAnnotation(name: String) =
    annotations.any { it.annotationType.resolve().declaration.qualifiedName?.asString() == name }