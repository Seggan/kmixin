package io.github.seggan.kmixin

import com.google.devtools.ksp.KspExperimental
import com.google.devtools.ksp.getDeclaredFunctions
import com.google.devtools.ksp.processing.CodeGenerator
import com.google.devtools.ksp.processing.Dependencies
import com.google.devtools.ksp.processing.Resolver
import com.google.devtools.ksp.symbol.ClassKind
import com.google.devtools.ksp.symbol.KSAnnotated
import com.google.devtools.ksp.symbol.KSClassDeclaration
import com.google.devtools.ksp.symbol.KSFile
import com.google.devtools.ksp.symbol.KSFunctionDeclaration

@OptIn(KspExperimental::class)
class KMixinProcessor(private val generator: CodeGenerator, private val resolver: Resolver) {
    fun processInterface(declaration: KSClassDeclaration) {
        if (declaration.classKind != ClassKind.INTERFACE) return
        val sb = StringBuilder()
        val pkg = declaration.packageName.asString() + ".impl"
        sb.append(createFileHeader(declaration, pkg))
        sb.append("public interface ")
            .append(declaration.simpleName.asString())
            .append(" extends ")
            .append(declaration.qualifiedName!!.asString())
            .append(" {\n")
        for (prop in declaration.getAllProperties()) {
            prop.getter?.let { getter ->
                sb.append("    ").append(generateAnnotations(getter))
                sb.append("    public ")
                    .append(getter.returnType!!.resolve().javaType)
                    .append(' ')
                    .append(resolver.getJvmName(getter)!!)
                    .append("();\n")
            }
            prop.setter?.let { setter ->
                sb.append("    ").append(generateAnnotations(setter))
                sb.append("    public void ")
                    .append(resolver.getJvmName(setter)!!)
                    .append('(')
                    .append(prop.type.resolve().javaType)
                    .append(" value);\n")
            }
            sb.appendLine()
        }
        for (function in declaration.getDeclaredFunctions().filter { it.simpleName.asString() != "<init>" }) {
            sb.appendLine()
            sb.append(generateAnnotations(function))
            sb.append("    public void ").append(function.simpleName.asString()).append('(')
            for (param in function.parameters) {
                sb.append(param.type.resolve().javaType).append(' ').append(param.name!!.asString()).append(", ")
            }
            if (sb.last() != '(') sb.setLength(sb.length - 2) // Remove last ", "
            sb.appendLine(");\n")
        }

        sb.append("}\n")

        generator.createNewFile(
            dependencies = Dependencies(false, declaration.containingFile!!),
            packageName = pkg,
            fileName = declaration.simpleName.asString(),
            extensionName = "java"
        ).use { it.write(sb.toString().encodeToByteArray()) }
    }

    fun processFile(file: KSFile) {
        val sb = StringBuilder()
        val pkg = file.packageName.asString() + ".impl"
        sb.append(createFileHeader(file, pkg))

        val className = file.fileName.removeSuffix(".kt")
        sb.append("public abstract class ").append(className).append(" {\n")
        for (function in file.declarations.filter { it.hasAnnotation(SpongeNames.INJECT) }) {
            if (function !is KSFunctionDeclaration) continue
            sb.appendLine(processFunction(function).prependIndent("    "))
        }
        sb.append("}\n")

        generator.createNewFile(
            dependencies = Dependencies(false, file),
            packageName = pkg,
            fileName = className,
            extensionName = "java"
        ).use { it.write(sb.toString().encodeToByteArray()) }
    }

    private fun generateAnnotations(annotated: KSAnnotated) = buildString {
        for (annotation in annotated.annotations) {
            if (annotation.annotationType.resolve().javaType.startsWith("kotlin.")) continue
            appendLine(annotation.toJava())
        }
    }

    private fun createFileHeader(annotated: KSAnnotated, pkg: String) = buildString {
        append("// Auto-generated by KMixin\n")
        if (pkg.isNotEmpty()) {
            append("package ").append(pkg).append(";\n\n")
        }
        appendLine("import ${SpongeNames.CALLBACK_INFO};")
        appendLine("import ${SpongeNames.CALLBACK_INFO_RETURNABLE};")

        appendLine()
        append(generateAnnotations(annotated))
    }

    private fun processFunction(function: KSFunctionDeclaration): String {
        val sb = StringBuilder()
        sb.append(generateAnnotations(function))
        sb.append("private")
        if (function.extensionReceiver == null) sb.append(" static")
        sb.append(" void ").append(function.simpleName.asString()).append('(')
        val returnType = function.returnType!!.resolve().javaBoxedType
        for (param in function.parameters) {
            val type = param.type.resolve().javaType
            if (type == SpongeNames.CALLBACK_INFO || type == SpongeNames.CALLBACK_INFO_RETURNABLE) continue
            sb.append(type).append(' ').append(param.name!!.asString()).append(", ")
        }
        if (sb.last() != '(') {
            sb.setLength(sb.length - 2) // Remove last ", "
        }
        if (function.hasAnnotation(SpongeNames.INJECT)) {
            if (sb.last() != '(') sb.append(", ")
            if (returnType != "void") {
                sb.append("CallbackInfoReturnable<").append(returnType).append("> ci")
            } else {
                sb.append("CallbackInfo ci")
            }
        }
        sb.append(") {\n    ")
        if (function.hasAnnotation(SpongeNames.INJECT) && returnType != "void") sb.append("ci.setReturnValue(")
        sb.append(resolver.getOwnerJvmClassName(function)!!)
            .append('.')
            .append(resolver.getJvmName(function)!!)
            .append('(')
        if (function.extensionReceiver != null) {
            sb.append('(').append(function.extensionReceiver!!.resolve().javaType).append(") (Object) this")
            if (function.parameters.isNotEmpty()) sb.append(", ")
        }
        if (function.hasAnnotation(SpongeNames.INJECT)) {
            if (function.parameters.isNotEmpty()) {
                val param = function.parameters.singleOrNull()
                    ?: throw IllegalArgumentException("@Inject function must have zero or one parameters")
                if (param.type.resolve().javaType == SpongeNames.CALLBACK_INFO || param.type.resolve().javaType == SpongeNames.CALLBACK_INFO_RETURNABLE) {
                    sb.append("ci")
                } else {
                    sb.append("ci.getReturnValue()")
                }
            }
        } else {
            for ((i, param) in function.parameters.withIndex()) {
                sb.append(param.name!!.asString())
                if (i < function.parameters.size - 1) sb.append(", ")
            }
        }
        sb.append(")")
        if (function.hasAnnotation(SpongeNames.INJECT) && returnType != "void") sb.append(")")
        sb.append(";\n}")
        return sb.toString()
    }
}